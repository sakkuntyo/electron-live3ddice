<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>three.js Cube (D6)</title>

  <!-- three „Å® addons „ÅÆËß£Ê±∫ÂÖà„ÇíÊåáÂÆö -->
  <script type="importmap">
  {
    "imports": {
      "three": "./node_modules/three/build/three.module.js",
      "three/addons/": "./node_modules/three/examples/jsm/"
    }
  }
  </script>

  <style>
    html,body{margin:0;height:100%;background:#0f0;}
    canvas{display:block;width:100%;height:100%}
  </style>
</head>
<body>
  <div id="overlay">
    <button id="rollBtn" class="btn">üé≤ Roll</button>
    <button id="autoBtn" class="btn">Auto-rotate: <span id="autoState">ON</span></button>
    <span>dice
      <input id="dicex" type="range" min="1" max="100" value="1">
      <span id="dicexVal">x 0.1</span>
      <input id="dicey" type="range" min="1" max="100" value="1">
      <span id="diceyVal">y 0.1</span>
      <input id="dicez" type="range" min="1" max="100" value="1">
      <span id="dicezVal">z 0.1</span>
    </span>
    <!--
    <span>camera
      <input id="camerax" type="range" min="1" max="30" value="1">
      <span id="cameraxVal">x 0.1</span>
      <input id="cameray" type="range" min="1" max="30" value="1">
      <span id="camerayVal">y 0.1</span>
      <input id="cameraz" type="range" min="1" max="30" value="1">
      <span id="camerazVal">z 0.1</span>
    </span>
    -->
  </div>

  <script type="module">
    import * as THREE from './node_modules/three/build/three.module.js';
    import { OrbitControls } from './node_modules/three/examples/jsm/controls/OrbitControls.js';

    // ===== Âü∫Êú¨„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó =====
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(3.5, 3.5, 3.5);
//    camera.position.set(0, 0, 0);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // „É©„Ç§„Éà
    scene.add(new THREE.AmbientLight(0xffffff, 0.55));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5, 8, 3);
    scene.add(dir);

    // ===== „Çµ„Ç§„Ç≥„É≠„ÅÆ„Éû„ÉÜ„É™„Ç¢„É´Ôºà1„Äú6„ÅÆÊï∞Â≠ó„ÇíCanvas„ÅßÊèèÁîªÔºâ =====
    function faceTexture(n) {
      const c = document.createElement('canvas');
      c.width = c.height = 256;
      const g = c.getContext('2d');
      // Èªí„Éô„Éº„Çπ + „ÅÜ„Å£„Åô„ÇâÂÜÖÂÅ¥„Ç∞„É≠„Éº
      const grd = g.createRadialGradient(128,128,10,128,128,140);
      grd.addColorStop(0, '#121212');
      grd.addColorStop(1, '#000000');
      g.fillStyle = grd;
      g.fillRect(0,0,256,256);

      g.fillStyle = '#e5e5e5';
      g.font = 'bold 160px system-ui, -apple-system, "Segoe UI", Roboto';
      g.textAlign = 'center';
      g.textBaseline = 'middle';
      g.fillText(String(n), 128, 140);

      const tex = new THREE.CanvasTexture(c);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy?.() ?? 1;
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    // BoxGeometry „ÅÆÈù¢È†ÜÔºàthreeÊ®ôÊ∫ñÔºâ„ÅØÔºö
    // 0: RIGHT, 1: LEFT, 2: TOP, 3: BOTTOM, 4: FRONT, 5: BACK
    // Êï∞Â≠ó„ÅÆÂâ≤„ÇäÂΩì„Å¶„ÅØ„ÅäÂ•Ω„Åø„Åß„ÄÇÔºà„Åì„Åì„Åß„ÅØ FRONT=2, BACK=5 „Å™„Å©„Å®„Åó„Å¶„ÅÑ„Åæ„ÅôÔºâ
    const materials = [
      new THREE.MeshStandardMaterial({ map: faceTexture(3) }), // RIGHT
      new THREE.MeshStandardMaterial({ map: faceTexture(4) }), // LEFT
      new THREE.MeshStandardMaterial({ map: faceTexture(1) }), // TOP
      new THREE.MeshStandardMaterial({ map: faceTexture(6) }), // BOTTOM
      new THREE.MeshStandardMaterial({ map: faceTexture(2) }), // FRONT
      new THREE.MeshStandardMaterial({ map: faceTexture(5) })  // BACK
    ];

    const cube = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), materials);
    scene.add(cube);

    // „ÅÜ„Å£„Åô„Çâ„Ç®„ÉÉ„Ç∏
    const edges = new THREE.LineSegments(
      new THREE.EdgesGeometry(cube.geometry),
      new THREE.LineBasicMaterial({ color:0x333333 })
    );
    cube.add(edges);

    // ===== Êìç‰ΩúÁ≥ªÔºà‰ªªÊÑèÔºâ =====
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.07;
    controls.enablePan = false;
    controls.minDistance = 2.2;
    controls.maxDistance = 8;

    // ===== Auto Rotate =====
    let autoRotate = true;
    const autoState = document.getElementById('autoState');

    // ===== RollÔºà90¬∞Âçò‰Ωç„Åß„Å¥„Å£„Åü„ÇäÊ≠¢„Åæ„ÇãÔºâ =====
    function randInt(min, max) { return (min + Math.floor(Math.random() * (max - min + 1))); }

function roll() {
  const q = Math.PI / 2;

  auto.active = false;

  const spinsX = randInt(0, 4);   // ‚ÜêÂõûËª¢Êï∞„ÅäÂ•Ω„Åø„Åß
  const spinsY = randInt(0, 4);
  const endXIdx = randInt(0, 3);
  const endYIdx = randInt(0, 3);

  const startX = cube.rotation.x;
  const startY = cube.rotation.y;

  const curXIdx = Math.round(startX / q);
  const curYIdx = Math.round(startY / q);
  const dQuarterX = ((endXIdx - curXIdx) % 4 + 4) % 4;
  const dQuarterY = ((endYIdx - curYIdx) % 4 + 4) % 4;

  const deltaX = dQuarterX * q + spinsX * 2 * Math.PI;
  const deltaY = dQuarterY * q + spinsY * 2 * Math.PI;

  const endX = startX + deltaX;
  const endY = startY + deltaY;

  const duration = 3000;
  const t0 = performance.now();
  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

  function step(now) {
    const t = Math.min(1, (now - t0) / duration);
    const k = easeOutCubic(t);
    cube.rotation.x = startX + deltaX * k;
    cube.rotation.y = startY + deltaY * k;

    if (t < 1) {
      requestAnimationFrame(step);
    } else {
      // ‚òÖ ËøΩÂä†Ôºö„Ç™„Éº„Éà„ÅåON„Å™„ÇâÂÜçÈñã‰∫àÁ¥Ñ
      if (auto.enabled) {
        auto.active = false;
        auto.nextAt = performance.now() + 800;
      }
    }
  }
  requestAnimationFrame(step);
}

// ==== Auto-rotateÔºàroll „Å®Âêå„Åò„Åè Euler „ÇíË£úÈñìÔºâ====
const Q = Math.PI / 2;                         // 90¬∞
const ease = t => 1 - Math.pow(1 - t, 3);      // easeOutCubic

const auto = {
  enabled: true,   // Auto-rotate „ÅÆ ON/OFF
  active:  false,
  startX: 0, startY: 0,
  endX:   0, endY:   0,
  t0: 0, dur: 2000,
  nextAt: 0
};

// „Éú„Çø„É≥„Åß ON/OFF
autoBtn.addEventListener('click', () => {
  auto.enabled = !auto.enabled;
  autoState.textContent = auto.enabled ? 'ON' : 'OFF';
  if (!auto.enabled) auto.active = false;
});

// Ê¨°„ÅÆ„Ç¥„Éº„É´Ôºà3„Äú4ÂõûËª¢„Åó„Å¶„Åã„Çâ 90¬∞„Å´ÂèéÊùüÔºâ
function planAuto(spinsMin = -10, spinsMax = 10) {
  const sx = randInt(spinsMin, spinsMax);  // X ÊñπÂêë„ÅÆÂõûËª¢ÂõûÊï∞
  const sy = randInt(spinsMin, spinsMax);  // Y ÊñπÂêë„ÅÆÂõûËª¢ÂõûÊï∞
  const ex = randInt(0, 3);                // 0,90,180,270¬∞
  const ey = randInt(0, 3);

  auto.startX = cube.rotation.x;
  auto.startY = cube.rotation.y;

  const curX = Math.round(auto.startX / Q);
  const curY = Math.round(auto.startY / Q);
  const dqX  = ((ex - curX) % 4 + 4) % 4;
  const dqY  = ((ey - curY) % 4 + 4) % 4;

  auto.endX = auto.startX + dqX * Q + sx * 2 * Math.PI;
  auto.endY = auto.startY + dqY * Q + sy * 2 * Math.PI;

  auto.t0  = performance.now();
  auto.dur = 10000; //1Âõû„Å´„Åã„Åë„ÇãÊôÇÈñì
  auto.active = true;
}

// 1„Éï„É¨„Éº„É†ÈÄ≤„ÇÅ„Çã
function stepAuto(now){
  if (!auto.active) return;
  const t = Math.min(1, (now - auto.t0) / auto.dur);
  const k = ease(t);
  cube.rotation.x = auto.startX + (auto.endX - auto.startX) * k;
  cube.rotation.y = auto.startY + (auto.endY - auto.startY) * k;

  if (t >= 0.7) {
    // ÊúÄÂæå„Å´ 90¬∞„Ç∞„É™„ÉÉ„Éâ„Å∏„Çπ„Éä„ÉÉ„Éó
    cube.rotation.x = Math.round(cube.rotation.x / Q) * Q;
    cube.rotation.y = Math.round(cube.rotation.y / Q) * Q;
    auto.active = false;
    auto.nextAt = now; //Ê≠¢„Åæ„Çã„Çà„ÇäÂ∞ë„ÅóÂâç„Å´Ê¨°„Å´ÈÄ≤„ÇÄ
  }
}

    document.getElementById('rollBtn').addEventListener('click', roll);

    // ===== „É´„Éº„Éó =====
    function tick() {
  const now = performance.now();

  if (auto.enabled) {
    if (!auto.active && now >= auto.nextAt) planAuto();
    stepAuto(now);
  }

  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(tick);
    }
    tick();

    // ===== „É™„Çµ„Ç§„Ç∫ÂØæÂøú =====
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });



    //input
    dicex.addEventListener("input", e => {
      dicexVal.textContent = `x ${e.target.value / 10}`;
      cube.rotation.x = e.target.value / 10
    });
    dicey.addEventListener("input", e => {
      diceyVal.textContent = `y ${e.target.value / 10}`;
      cube.rotation.y = e.target.value / 10
    });
    dicez.addEventListener("input", e => {
      dicezVal.textContent = `z ${e.target.value / 10}`;
      cube.rotation.z = e.target.value / 10
    });
    camerax.addEventListener("input", e => {
      controls.enableDamping = false;               // ÁµåË∑Ø‰æùÂ≠ò„ÇíÁÑ°„Åè„Åô
      cameraxVal.textContent = `x ${e.target.value / 10}`;
      camera.position.x = e.target.value / 10
      controls?.update();   
    });
    cameray.addEventListener("input", e => {
      controls.enableDamping = false;               // ÁµåË∑Ø‰æùÂ≠ò„ÇíÁÑ°„Åè„Åô
      camerayVal.textContent = `y ${e.target.value / 10}`;
      camera.position.y = e.target.value / 10
      controls?.update();   
    });
/* „Å™„Åè„Å¶„ÅÑ„ÅÑ„Åã„ÇÇ
    cameraz.addEventListener("input", e => {
      controls.enableDamping = false;               // ÁµåË∑Ø‰æùÂ≠ò„ÇíÁÑ°„Åè„Åô
      camerazVal.textContent = `z ${e.target.value / 10}`;
      camera.position.z = e.target.value / 10
      controls?.update();   
    });
*/
  </script>
</body>
</html>
